# 前端工程化

## 什么是前端工程化
我们先来看看这一章的学习内容：

<img :src="$withBase('/projectable-devtools.png')" alt="">

什么是前端工程化？<font color=#DD1144>前端工程化指的是将前端开发的流程规范会，标准化，包括开发流程，技术选型，代码规范，构建发布等，用于提升前端工程师的开发效率和代码质量</font>

+ <font color=#DD1144>开发流程</font>：需求分析，版本控制，缺陷管理，文档管理，自动化，性能测试，发布部署

+ <font color=#DD1144>技术选型</font>：UI框架，Js框架

+ <font color=#DD1144>代码规范</font>：`Standard`、`airbnb`、`Prettier`，模块化

+ <font color=#DD1144>构建发布</font>：`Jenkins`、`Webpack`、`Gulp`、`Docker`

也并不是我们所有的东西都要学习，人的精力是有限的，但是从广泛的意义讲，很多东西你要知道，具体遇到问题就有解决问题的思路和方向。在现在对前端工程化有了更加细致的划分，比如下面这种：

<font color=#1E90FF>前端工程可以定义为，将工程方法系统化地应用到前端开发中，以系统、严谨、可量化的方法开发、运营、维护前端应用程序</font>

前端越来越重，复杂度越来越高，配套的前端工程体系也在不断发展和完善，可简单分为开发、构建、发布 3 条主线：
+ <font color=#9400D3>前端框架</font>：插件化（`jQuery`） -> 模块化（`RequireJS`） -> 组件化（`React`）
+ <font color=#9400D3>构建工具</font>：任务化（`grunt/gulp`） -> 系统化（`webpack`）
+ <font color=#9400D3>CI/CD</font>：工具化（`Jenkins`） -> 自动化（`Web Hook`）

三大主线撑起了前端工程体系，系统地覆盖了前端开发的主流程，其中的工程方法也彼此互补、相互影响，体现在：
+ 构建工具让百花齐放前端框架、类库能够无缝合作
+ 前端框架、类库也在一定程度上影响着构建工具（如模块加载、CSS 预处理）、甚至`CI/CD`（如`SSR`）

<font color=#1E90FF>**① 开发阶段**</font>

开发阶段的首要任务是创建样板项目（一并选择前端框架、类库），接着开始修改-验证的主循环，主要涉及这些工程化设施：

+ 脚手架：创建前端应用的目录结构，并生成样板代码
+ 公共库：维护着可复用的 UI 组件、工具模块等公共资源
+ 包管理器：引入第三方库/组件，并跟踪管理这些依赖项
+ 编辑器：提供语法高亮、智能提示、引用跳转等功能，提升开发体验
+ 构建工具：提供语法校验、编译、打包、`DevServer`等功能，简化工作流
+ 调试套件：提供预览、`DevTools`、`Mock`、性能分析诊断等调试功能，加速修改-验证的主循环

<font color=#1E90FF>**② 测试阶段**</font>

开发完成，进入测试阶段，先要对整体功能进行充分自测，再移交专业的测试人员验证，过程中需要用到工程化设施有：

+ 单元测试框架：提供针对组件、逻辑的测试支持
+ 静态扫描工具：从代码质量、构建产物质量、最佳实践/开发规约等多个维度做静态检查
+ 自动化测试工具：针对 UI 效果和业务流程，提供测试支持
+ 性能测试工具：监测并统计出相对准确的性能数据

<font color=#1E90FF>**③ 构建阶段**</font>

不同于开发阶段，在构建阶段要做更多的极限优化和流程联动，涉及：
+ 打包脚本：在语法校验、编译、打包的基础上，进行合并、压缩、代码拆分、图片处理、SSR等极限优化
+ 构建服务：支持多任务并行打包、通知

<font color=#1E90FF>**④ 部署阶段**</font>

最后将经过充分测试的前端应用程序部署到生产环境，需要这些工程化工具：
+ 发布平台：将前端资源上传至`CDN`或`SSR`渲染服务，或者以离线包的形式集成到移动客户端
+ 迭代管理平台：提供`CI/CD`支持

<font color=#1E90FF>**⑤ 监控阶段**</font>

前端应用程序上线之后，还需要持续关注线上的实际效果和异常情况，依赖这些工程设施：
+ 埋点平台：统计、分析业务数据，跟踪性能指标
+ 监控平台：观察线上的异常信息，包括报错、白屏、流量异常等

## 怎么做前端工程化
前端工程化也是有规模的，并不是所有项目都需要很复杂的前端工程化

比如小的团队，可以从<font color=#1E90FF>业务</font>着手，简单的单页面应用，使用`gulp`打包+ 同步工具实现开发全流程

如果是比较复杂的项目，我们就可以考虑现有成熟化的产品，比如`Jenkins`(CI工具)+`git/gitlab`(版本控制工具)+`webpack`(构建工具) + `React/Vue`(前端框架)

<img :src="$withBase('/bigfrontend-devop-14.png')" alt="">

## 构建工具
四款前端主流的打包工具：<font color=#9400D3>grunt</font> ，<font color=#9400D3>gulp</font>，<font color=#9400D3>webpack</font>， <font color=#9400D3>rollup</font>，以发布时间为顺序。

+ <font color=#1E90FF>Grunt</font>：最老牌的打包工具，它运用配置的思想来写打包脚本，一切皆配置，所以会出现比较多的配置项，诸如`option`,`src`,`dest`等等。而且不同的插件可能会有自己扩展字段，认知成本高，运用的时候需要明白各种插件的配置规则。
+ <font color=#1E90FF>Gulp</font>：用代码方式来写打包脚本，并且代码采用流式的写法，只抽象出了`gulp.src`, `gulp.pipe`, `gulp.dest`, `gulp.watch`接口，运用相当简单。更易于学习和使用，使用`gulp`的代码量能比`grunt`少一半左右。
+ <font color=#1E90FF>Webpack</font>: 是模块化管理工具和打包工具。通过`loader`的转换，任何形式的资源都可以视作模块，比如`CommonJs`模块、`AMD`模块、`ES6`模块、`CSS`、图片等。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。它定位是模块打包器，而`Gulp/Grunt`属于构建工具。`Webpack`可以代替 Gulp/Grunt 的一些功能，但不是一个职能的工具，可以配合使用。
+ <font color=#1E90FF>Rollup</font>：下一代`ES6`模块化工具，最大的亮点是利用`ES6`模块设计，利用`tree-shaking`生成更简洁、更简单的代码。一般而言，对于应用使用`Webpack`，对于类库使用`Rollup`；需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多`CommonJS`模块的依赖时，使用`webpack`。代码库是基于`ES6`模块，而且希望代码能够被其他人直接使用，使用`Rollup`。

使用总结：
+ `Grunt`：MPA，老牌打包工具，基于文件为媒介（运行慢，零散的脚本文件一当多起来就受到影响
+ `Gulp`：MPA，易学，基于nodejs的steam流打包
+ `Webpack`：SPA，目前最强大的打包工具，但是过于臃肿，如何单纯打包js不推荐
+ `Roleup`：MPA，tree-shaking特性（针对es6，按需打包，多余的不要，目前（2018，vuex,react主流使用）


关于`webpack`，我们在之前[前端工具](https://taopoppy.cn/Webpack/)已经详细的学习过了，去哪里学习即可。后续我们在学习`CL/CD`的时候还会涉及一些相关的知识。